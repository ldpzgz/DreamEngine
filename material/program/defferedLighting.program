vs{
	#version 330 core
    layout(location = 0) in vec3 inPos;
    layout(location = 1) in vec2 inTexcoord;
	uniform mat4 mvpMat;
    out vec2 texcoord;
    void main()
    {
       gl_Position = mvpMat * vec4(inPos,1.0f);
       texcoord = inTexcoord;
    }
}
fs{
	#version 330 core
	precision highp float;
	const float PI = 3.14159265359;
	
	out vec4 FragColor;
	
	in vec2 texcoord;

	uniform sampler2D posMap;
	uniform sampler2D albedoMap;
	uniform sampler2D normalMap;
	uniform sampler2D metallicMap;
	uniform sampler2D roughnessMap;
	// IBL
	uniform samplerCube irrMap;
	uniform samplerCube prefilterMap;
	uniform sampler2D brdfLUT;
	
	uniform vec3 lightPos;
	uniform vec3 lightColor;

	/*Trowbridge-Reitz GGX normal distribution function
	*	N is normal,
	*	H is half vector
	*	
	*/
	float DistributionGGX(vec3 N, vec3 H, float roughness)
	{
		float a 	 = roughness*roughness;
		float a2     = a*a;
		float NdotH  = max(dot(N, H), 0.0f);
		float NdotH2 = NdotH*NdotH;
		
		float nom    = a2;
		float denom  = (NdotH2 * (a2 - 1.0f) + 1.0f);
		denom        = PI * denom * denom;
		
		return nom / denom;
	}
	
	/*Geometry function Schlick-GGX 
	*	k is remaping of roughness ,
	*	for direct lighting k=(a+1)2 / 8
	*	or IBL lighting k = a2 / 2
	*/
	float GeometrySchlickGGX(float NdotV, float roughness)
	{
		float r = (roughness + 1.0);
		float k = (r*r) / 8.0f;

		float num   = NdotV;
		float denom = NdotV * (1.0f - k) + k;
		
		return num / denom;
	}
	  
	float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
	{
		float NdotV = max(dot(N, V), 0.0f);
		float NdotL = max(dot(N, L), 0.0f);
		float ggx1 = GeometrySchlickGGX(NdotV, roughness);
		float ggx2 = GeometrySchlickGGX(NdotL, roughness);
		
		return ggx1 * ggx2;
	}
	
	/*Fresnel-Schlick approximation
	*	cosTheta being the dot product result between the surface's normal n and the halfway h (or view v) direction
	* 	vec3 F0 = vec3(0.04);
	*	F0 = mix(F0, surfaceColor.rgb, metalness);
	*/
	vec3 fresnelSchlick(float cosTheta, vec3 F0)
	{
		return F0 + (1.0f - F0) * pow(clamp(1.0f - cosTheta, 0.0f, 1.0f), 5.0f);
	}
	
	vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
	{
		return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
	}
	
	vec3 directLight(float roughness,float metallic,vec3 F0,vec3 albedo,vec3 worldPos,vec3 normal,vec3 lightPos,vec3 lightColor){
		vec3 Lo = vec3(0.0f);
		vec3 camPos = vec3(0.0f,0.0f,0.0f);
		vec3 V = camPos-worldPos;
		// calculate per-light radiance
		vec3 L = normalize(lightPos - worldPos);
		vec3 H = normalize(V + L);
		float distance    = length(lightPos - worldPos);
		float attenuation = 1.0f / (distance*distance);
		vec3 radiance     = lightColor * attenuation;        
		
		// cook-torrance brdf
		float NDF = DistributionGGX(normal, H, roughness);        
		float G   = GeometrySmith(normal, V, L, roughness);      
		vec3 F    = fresnelSchlick(max(dot(H, V), 0.0f), F0);       
		
		vec3 kS = F;
		vec3 kD = vec3(1.0f) - kS;
		kD *= 1.0f - metallic;	  
		
		vec3 numerator    = NDF * G * F;
		float denominator = 4.0f * max(dot(normal, V), 0.0f) * max(dot(normal, L), 0.0f) + 0.0001f;
		vec3 specular     = numerator / denominator;  
			
		// add to outgoing radiance Lo
		float NdotL = max(dot(normal, L), 0.0f);
		
		Lo += (kD * albedo / PI + specular) *radiance * NdotL;// 
		
		return Lo;
	}
	
	vec3 envLight(float roughness,float metallic,vec3 F0,vec3 albedo,vec3 worldPos,vec3 normal,samplerCube irrMap,samplerCube prefilterMap,sampler2D brdfLUT){
		vec3 V = normalize(vec3(0.0f,0.0f,0.0f) - worldPos);
		// ambient lighting (we now use IBL as the ambient term)
		vec3 F = fresnelSchlickRoughness(max(dot(normal, V), 0.0), F0, roughness);
		vec3 R = reflect(-V, normal);
		vec3 kS = F;
		vec3 kD = 1.0 - kS;
		kD *= 1.0 - metallic;	  
		
		vec3 irradiance = texture(irrMap, normal).rgb;
		vec3 diffuse      = irradiance * albedo;
		
		// sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.
		const float MAX_REFLECTION_LOD = 4.0;
		vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;    
		vec2 brdf  = texture(brdfLUT, vec2(max(dot(normal, V), 0.0), roughness)).rg;
		vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);
		//0.2f is ao;
		vec3 ambient = (kD * diffuse + specular) * 0.2f;
		return ambient;
	}
	

	void main()
	{             
		// retrieve data from G-buffer
		vec3 worldPos = texture(posMap, texcoord).rgb;
		vec3 normal = texture(normalMap, texcoord).rgb;
		vec3 albedo = texture(albedoMap, texcoord).rgb;
		float metallic = texture(metallicMap, texcoord).r;
		float roughness = texture(roughnessMap, texcoord).r;
		
		// calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 
		// of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)    
		vec3 F0 = vec3(0.04); 
		F0 = mix(F0, albedo, metallic);
		vec3 dirColor = directLight(roughness,metallic,F0,albedo,worldPos,normal,lightPos,lightColor);
		vec3 envColor = envLight(roughness,metallic,F0,albedo,worldPos,normal,irrMap,prefilterMap,brdfLUT);
		
		vec3 color = dirColor + envColor;
		// HDR tonemapping
		color = color / (color + vec3(1.0));
		// gamma correct
		color = pow(color, vec3(1.0/2.2)); 
		FragColor = vec4(color , 1.0);
	}  
}
program:defferedLighting{
	posLoc=0
	texcoordLoc=1
	mvpMatrix=mvpMat
	lightPos=lightPos
	lightColor=lightColor
	sampler{
		posMap=none
		albedoMap=none
		normalMap=none
		metallicMap=none
		roughnessMap=none
		irrMap=none
		prefilterMap=none
		brdfLUT=none
	}
}