vs{
	#version 330 core
    layout(location = 0) in vec3 inPos;
    layout(location = 1) in vec2 inTexcoord;
    out vec2 texcoord;
    void main()
    {
       gl_Position = vec4(inPos,1.0f);
       texcoord = inTexcoord;
    }
}
fs{
	#version 330 core
	precision highp float;
	const float PI = 3.14159265359f;
	
	out vec4 FragColor;
	
	in vec2 texcoord;

	uniform sampler2D posMap;//ao in a
	uniform sampler2D albedoMap;//roughness in a
	uniform sampler2D normalMap;//metallic in a
	// IBL
	uniform samplerCube irrMap;
	uniform samplerCube prefilterMap;
	uniform sampler2D brdfLUT;
	
	uniform vec3 lightPos;
	uniform vec3 lightColor;

	/*Trowbridge-Reitz GGX normal distribution function
	*	N is normal,
	*	H is half vector
	*	
	*/
	float DistributionGGX(vec3 N, vec3 H, float roughness)
	{
		float a 	 = roughness*roughness;
		float a2     = a*a;
		float NdotH  = max(dot(N, H), 0.0f);
		float NdotH2 = NdotH*NdotH;
		
		float nom    = a2;
		float denom  = (NdotH2 * (a2 - 1.0f) + 1.0f);
		denom        = PI * denom * denom;
		
		return nom / denom;
	}
	
	/*Geometry function Schlick-GGX 
	*	k is remaping of roughness ,
	*	for direct lighting k=(a+1)2 / 8
	*	or IBL lighting k = a2 / 2
	*/
	float GeometrySchlickGGX(float NdotV, float roughness)
	{
		float r = (roughness + 1.0);
		float k = (r*r) / 8.0f;

		float num   = NdotV;
		float denom = NdotV * (1.0f - k) + k;
		
		return num / denom;
	}
	  
	float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
	{
		float NdotV = max(dot(N, V), 0.0f);
		float NdotL = max(dot(N, L), 0.0f);
		float ggx1 = GeometrySchlickGGX(NdotV, roughness);
		float ggx2 = GeometrySchlickGGX(NdotL, roughness);
		
		return ggx1 * ggx2;
	}
	
	/*Fresnel-Schlick approximation
	*	cosTheta being the dot product result between the surface's normal n and the halfway h (or view v) direction
	* 	vec3 F0 = vec3(0.04);
	*	F0 = mix(F0, surfaceColor.rgb, metalness);
	*/
	vec3 fresnelSchlick(float HoV, vec3 F0)
	{
		return F0 + (1.0f - F0) * pow(clamp(1.0f - HoV, 0.0f, 1.0f), 5.0f);
	}
	
	vec3 fresnelSchlickRoughness(float NoV, vec3 F0, float roughness)
	{
		return F0 + (max(vec3(1.0f - roughness), F0) - F0) * pow(clamp(1.0f - NoV, 0.0f, 1.0f), 5.0f);
	}
	
	/*
	*filament的F函数的实现
	*/
	vec3 F_Schlick(const vec3 f0, float VoH) {
		float f = pow(1.0 - VoH, 5.0);
		return f + f0 * (1.0 - f);
	}

	float F_Schlick(float f0, float f90, float VoH) {
		return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
	}
	/*
	*filament的G函数的实现
	*/
	float V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {
		float a2 = roughness * roughness;
		float lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);
		float lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);
		return 0.5 / (lambdaV + lambdaL);
	}
	float V_SmithGGXCorrelatedFast(float NoV, float NoL, float roughness) {
		float a = roughness;
		float GGXV = NoL * (NoV * (1.0 - a) + a);
		float GGXL = NoV * (NoL * (1.0 - a) + a);
		return 0.5 / (GGXV + GGXL);
	}
	//用于clear coat layer的G函数实现，DF都与标准模型一样计算
	float V_Kelemen(float LoH) {
		return 0.25 / (LoH * LoH);
	}
	/*
	*filament的D函数的实现
	*/
	float D_GGX(float NoH, float roughness) {
		float a = NoH * roughness;
		float k = roughness / (1.0 - NoH * NoH + a * a);
		return k * k * (1.0 / PI);
	}
	/*
	*filament的D函数的mediump版本的实现
	*/
	#define MEDIUMP_FLT_MAX    65504.0
	#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)
	float D_GGX(float roughness, float NoH, const vec3 n, const vec3 h) {
		vec3 NxH = cross(n, h);
		float a = NoH * roughness;
		float k = roughness / (dot(NxH, NxH) + a * a);
		float d = k * k * (1.0 / PI);
		return saturateMediump(d);
	}
	
	vec3 directLight(float roughness,float metallic,vec3 F0,vec3 albedo,vec3 worldPos,vec3 normal,vec3 lightPos,vec3 lightColor){
		vec3 Lo = vec3(0.0f);
		vec3 camPos = vec3(0.0f,0.0f,0.0f);
		vec3 V = camPos-worldPos;
		// calculate per-light radiance
		vec3 L = normalize(lightPos - worldPos);
		vec3 H = normalize(V + L);
		float distance    = length(lightPos - worldPos);
		float attenuation = 1.0f / (distance*distance);
		vec3 radiance     = lightColor * attenuation;        
		
		// cook-torrance brdf
		float NoV = max(dot(normal, V), 0.0f);
		float NoL = max(dot(normal, L), 0.0f);
		float NDF = DistributionGGX(normal, H, roughness);        
		float G   = GeometrySmith(normal, V, L, roughness);
		//float G   = V_SmithGGXCorrelated(NoV,NoL, roughness);		
		vec3 F    = fresnelSchlick(max(dot(H, V), 0.0f), F0);

		float NDFc = DistributionGGX(normal, H, 0.1);
		float Gc = GeometrySmith(normal, V, L, 0.1);
		//float Gc   = V_SmithGGXCorrelated(NoV,NoL, 0.1);
		vec3 Fc    = fresnelSchlick(max(dot(H, V), 0.0f), vec3(0.04));
		
		vec3 numeratorC    = NDFc * Gc * Fc;
		float denominator = 4.0f * max(dot(normal, V), 0.0f) * max(dot(normal, L), 0.0f) + 0.0001f;
		vec3 specularC     = numeratorC / denominator;

		// filament brdf
		//float NDF = D_GGX(dot(normal, H), roughness);        
		//float G   = V_SmithGGXCorrelated(NoV,NoL, roughness);      
		//vec3 F    = F_Schlick(F0,max(dot(V, H), 0.0f)); 		
		
		vec3 kS = F;
		vec3 kD = vec3(1.0f) - kS;
		kD *= 1.0f - metallic;	  
		
		vec3 numerator    = NDF * G * F;
		//float denominator = 4.0f * max(dot(normal, V), 0.0f) * max(dot(normal, L), 0.0f) + 0.0001f;
		vec3 specular     = numerator / denominator;  
			
		// add to outgoing radiance Lo
		float NdotL = max(dot(normal, L), 0.0f);
		
		//
		Lo += ((kD * albedo / PI + specular)*(vec3(1.0)-Fc)+specularC) *radiance * NdotL;// 
		
		return Lo;
	}
	
	vec3 envLight(float ao,float roughness,float metallic,vec3 F0,vec3 albedo,vec3 worldPos,vec3 normal,samplerCube irrMap,samplerCube prefilterMap,sampler2D brdfLUT){
		vec3 V = normalize(vec3(0.0f,0.0f,0.0f) - worldPos);
		// ambient lighting (we now use IBL as the ambient term)
		vec3 F = fresnelSchlickRoughness(max(dot(normal, V), 0.0f), F0, roughness);
		vec3 Fc = fresnelSchlickRoughness(max(dot(normal, V), 0.0f), vec3(0.04), 0.1);
		vec3 R = reflect(-V, normal);
		vec3 kS = F;
		vec3 kD = 1.0f - kS;
		kD *= 1.0f - metallic;	  
		
		vec3 irradiance = texture(irrMap, normal).rgb;
		vec3 diffuse      = irradiance * albedo;
		
		// sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.
		const float MAX_REFLECTION_LOD = 4.0;
		vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;    
		vec2 brdf  = texture(brdfLUT, vec2(max(dot(normal, V), 0.0), roughness)).rg;
		vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);
		vec3 specularC = prefilteredColor * (Fc * brdf.x + brdf.y);
		vec3 l_fc = vec3(1.0)-Fc;
		vec3 sq1_fc = (vec3(1.0)-Fc)*(vec3(1.0)-Fc);
		vec3 ambient = (kD * diffuse*l_fc + specular*sq1_fc + specularC)*ao;
		return ambient;
	}
	

	void main()
	{             
		// retrieve data from G-buffer
		vec4 posRgba = texture(posMap, texcoord);
		vec4 normalRgba = texture(normalMap, texcoord);
		vec4 albedoRgba = texture(albedoMap, texcoord);
		vec3 worldPos = posRgba.rgb;
		vec3 normal = normalRgba.rgb;
		vec3 albedo = albedoRgba.rgb;
		float metallic = normalRgba.a;
		float roughness = albedoRgba.a;
		float ao = posRgba.a;
		
		// calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 
		// of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)    
		vec3 F0 = vec3(0.04); 
		F0 = mix(F0, albedo, metallic);
		//F0.r = pow(1.0-5.0*sqrt(F0.r),2.0)/pow(5.0-sqrt(F0.r),2);
		//F0.g = pow(1.0-5.0*sqrt(F0.g),2.0)/pow(5.0-sqrt(F0.g),2);
		//F0.b = pow(1.0-5.0*sqrt(F0.b),2.0)/pow(5.0-sqrt(F0.b),2);
		vec3 dirColor = directLight(roughness,metallic,F0,albedo,worldPos,normal,lightPos,lightColor);
		vec3 envColor = envLight(ao,roughness,metallic,F0,albedo,worldPos,normal,irrMap,prefilterMap,brdfLUT);
		
		vec3 color = dirColor + envColor;
		// HDR tonemapping
		color = color / (color + vec3(1.0));
		// gamma correct
		color = pow(color, vec3(1.0/2.2)); 
		FragColor = vec4(color , 1.0);
	}  
}
program:defferedLighting{
	posLoc=0
	texcoordLoc=1
	lightPos=lightPos
	lightColor=lightColor
	sampler{
		posMap=none
		albedoMap=none
		normalMap=none
		irrMap=none
		prefilterMap=none
		brdfLUT=none
	}
}